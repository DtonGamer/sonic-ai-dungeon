import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';
import { useWallet } from './WalletContext';
import { useGame } from './GameContext';
import { mintNFT, evolveNFT, fetchUserNFTs } from '../services/nftService';

interface NFT {
  id: string;
  name: string;
  description: string;
  imageUrl: string;
  attributes: {
    type: string;
    rarity: string;
    power: number;
    level: number;
    dragonScales?: boolean;
    elementalPower?: string;
  };
  evolutionStage: number;
  questsUsedIn: string[];
}

interface NFTContextType {
  nfts: NFT[];
  loading: boolean;
  mintNewNFT: (questId: string) => Promise<boolean>;
  evolveNFTWithQuest: (nftId: string, questId: string) => Promise<boolean>;
}

const NFTContext = createContext<NFTContextType>({
  nfts: [],
  loading: false,
  mintNewNFT: async () => false,
  evolveNFTWithQuest: async () => false,
});

export const useNFT = () => useContext(NFTContext);

interface NFTProviderProps {
  children: ReactNode;
}

export const NFTProvider: React.FC<NFTProviderProps> = ({ children }) => {
  const { connected, publicKey } = useWallet();
  const { playerStats } = useGame();
  const [nfts, setNfts] = useState<NFT[]>([]);
  const [loading, setLoading] = useState(false);

  // Load NFTs when wallet is connected
  useEffect(() => {
    if (connected && publicKey) {
      loadUserNFTs();
    }
  }, [connected, publicKey]);

  // Check for automatic NFT evolutions based on player stats
  useEffect(() => {
    if (playerStats.dragonsSlain >= 5) {
      // Find sword NFTs that can evolve with dragon scales
      const swordNFTs = nfts.filter(
        nft => nft.attributes.type === 'sword' && 
        nft.evolutionStage < 3 && 
        !nft.attributes.dragonScales
      );
      
      if (swordNFTs.length > 0) {
        // Evolve the first eligible sword with dragon scales
        evolveNFTWithDragonScales(swordNFTs[0].id);
      }
    }
  }, [playerStats, nfts]);

  const loadUserNFTs = async () => {
    if (!publicKey) return;
    
    setLoading(true);
    try {
      const userNFTs = await fetchUserNFTs(publicKey);
      setNfts(userNFTs);
    } catch (error) {
      console.error("Failed to load NFTs:", error);
    } finally {
      setLoading(false);
    }
  };

  const mintNewNFT = async (questId: string) => {
    if (!publicKey) return false;
    
    setLoading(true);
    try {
      const newNFT = await mintNFT(publicKey, questId);
      if (newNFT) {
        setNfts(prev => [...prev, newNFT]);
        return true;
      }
      return false;
    } catch (error) {
      console.error("Failed to mint NFT:", error);
      return false;
    } finally {
      setLoading(false);
    }
  };

  const evolveNFTWithQuest = async (nftId: string, questId: string) => {
    if (!publicKey) return false;
    
    setLoading(true);
    try {
      const evolvedNFT = await evolveNFT(publicKey, nftId, questId);
      if (evolvedNFT) {
        setNfts(prev => prev.map(nft => 
          nft.id === nftId ? evolvedNFT : nft
        ));
        return true;
      }
      return false;
    } catch (error) {
      console.error("Failed to evolve NFT:", error);
      return false;
    } finally {
      setLoading(false);
    }
  };

  const evolveNFTWithDragonScales = async (nftId: string) => {
    if (!publicKey) return false;
    
    setLoading(true);
    try {
      // In a real implementation, this would call the backend to evolve the NFT
      const nftToEvolve = nfts.find(nft => nft.id === nftId);
      
      if (!nftToEvolve) return false;
      
      const evolvedNFT: NFT = {
        ...nftToEvolve,
        name: `${nftToEvolve.name} of Dragon's Bane`,
        description: `${nftToEvolve.description} This sword has been infused with the scales of slain dragons, giving it a unique shimmering appearance and increased power against draconic foes.`,
        imageUrl: `https://replicate.delivery/pbxt/JYIFnmbzLGwxDQnkk6r4gWnPfLYRKZ5WK4NBbzTkgSXfchuQA/out-0.png`, // This would be generated by Stable Diffusion
        attributes: {
          ...nftToEvolve.attributes,
          power: nftToEvolve.attributes.power + 15,
          dragonScales: true,
        },
        evolutionStage: nftToEvolve.evolutionStage + 1,
      };
      
      setNfts(prev => prev.map(nft => 
        nft.id === nftId ? evolvedNFT : nft
      ));
      
      return true;
    } catch (error) {
      console.error("Failed to evolve NFT with dragon scales:", error);
      return false;
    } finally {
      setLoading(false);
    }
  };

  const value = {
    nfts,
    loading,
    mintNewNFT,
    evolveNFTWithQuest,
  };

  return (
    <NFTContext.Provider value={value}>
      {children}
    </NFTContext.Provider>
  );
};